/*
see full version history at 

https://github.com/patrick4007019/khanacademy/commits/main/stranded%20khan

*/
//jshint asi: true
//jshint esnext: true

//{
noStroke()
let ran = round(random(0, 10000))
let sc = "home", keys = [], seed = new Random(ran), bs = [], px = 0, py = 0, pd = 0, loading, islands = [], dup = false, finish = false, check = 0, ps = false, con2 = false, hr = 17, plants = []
let tcontrol = "Arrow Keys to move\nC to open crafting menu\nE to open inventory\nZ to toggle pause menu"
let hm = [
    "00000000330000000",
    "00000333133000000",
    "00033311113300000",
    "00331111213330000",
    "03331112211130000",
    "00311222221130000",
    "0333112222113000",
    "00331122211330",
    "000331122211330",
    "00331112211133000",
    "00033311111133000",
    "00000333113300000",
    "00000003333000000"
]
let c1 = color(0, 0, 150)
let f = 1
//} basic vars
//{
//put your save code here:
let savecode = ""
//island size (increases logarithmically)
let islandSize = 300
//load speed (faster load speed = higher chance of crashes)
let loadSpeed = 20
//player speed 
let spd = 0.7
//land stroke
//} setting vars
//{
function Palm(x, y) {
    this.x = x
    this.y = y
    this.draw = function() {
        stroke(0, f*150, 0)
        strokeWeight(2)
        fill(0, f*255, f*98)
        rect(this.x+2, this.y+2, 16, 16, 3)
        fill(0, f*255, f*150);
        rect(this.x+5, this.y+5, 10, 10, 2)
    }
}
//} plant/tree constructors
//{
function Land(x, y) {
    this.x = x
    this.y = y
    this.rand = seed.nextGaussian()
    this.check = function() {
        if(check === 0) {
        this.count = 0
        for(let i = 0; i < bs.length; i++) {
            if(
            (bs[i].x === this.x-20 && bs[i].y === this.y) ||
            (bs[i].x === this.x+20 && bs[i].y === this.y) ||
            (bs[i].x === this.x && bs[i].y === this.y-20) || 
            (bs[i].x === this.x && bs[i].y === this.y+20) ||
            (bs[i].x === this.x-20 && bs[i].y === this.y-20) ||
            (bs[i].x === this.x-20 && bs[i].y === this.y+20) ||
            (bs[i].x === this.x+20 && bs[i].y === this.y-20) ||
            (bs[i].x === this.x+20 && bs[i].y === this.y+20)
            ) {
                this.count++
            }
        }
        switch(this.count) {
            case 8: this.col = color(0, f*220, 0); break
            case 9: this.col = color(0, f*190, 0); break
            case 10: this.col = color(0, f*170, 0); break
            default: this.col = color(f*255, f*255, f*150);
        }
        if(this.count > 10) {this.col = color(0, f*100, f*255)}
        
        if(this.count > 7 && this.count < 11) {this.grow = true}
        if(this.rand < -0.85 && this.grow) {plants.push(new Palm(this.x, this.y))}
        }
    }
    this.check()
    this.draw = function() {
        switch(this.count) {
            case 8: this.col = color(0, f*220, 0); break
            case 9: this.col = color(0, f*190, 0); break
            case 10: this.col = color(0, f*170, 0); break
            default: this.col = color(f*255, f*255, f*150);
        }
        if(this.count > 10) {this.col = color(0, f*100, f*255)}
        stroke(this.col)
        strokeWeight(1)
        fill(this.col)
        rect(this.x, this.y, 20, 20)
    }
}
function Island(x, y) {
    this.x = x
    this.y = y
    this.n = seed.nextGaussian()
    this.ch = 0
    this.unique = []
    this.c = [new PVector(x, y)]
    this.dir = (this.n < -1 && new PVector(0, -20)) || (this.n > -1 && this.n < 0 && new PVector(20, 0)) || (this.n > 0 && this.n < 1 && new PVector(0, 20)) || (this.n > 1 && new PVector(-20, 0))
    this.finish = false
    this.lb = function() {
        this.n = seed.nextGaussian()
        this.dir = (this.n < -1 && new PVector(0, -20)) || (this.n > -1 && this.n < 0 && new PVector(20, 0)) || (this.n > 0 && this.n < 1 && new PVector(0, 20)) || (this.n > 1 && new PVector(-20, 0))
        this.c.push(new PVector(this.c[this.ch].x+this.dir.x, this.c[this.ch].y+this.dir.y))
        
        this.ch = abs(round(this.c.length*seed.nextGaussian()))
        this.ch = constrain(this.ch, 0, this.c.length-1)
    }
    this.rd = function() {
        for(let i = 0; i < this.c.length; i++) {
            for(let j = 0; j < this.c.length; j++) {
                if(this.c[i] && this.c[j] && this.c[i].x === this.c[j].x && this.c[i].y === this.c[j].y && i !== j) {
                    this.c.splice(j, 1) 
                }
            }
        }
        for(let i = 0; i < this.c.length; i++) {
            bs.push(new Land(this.c[i].x, this.c[i].y))
        }
        dup = false
        this.finish = true
    }
}
for(let i = 1; i < 4; i++) {for(let j = 1; j < 4; j++) {
    islands.push(new Island(i*600-1080, j*600-1080))
}}
//} land constructors
//{
function HUD() {
    fill(255, 255, 255)
    textSize(15)
    text(abs(round(-px/10*2)) + (px < 0 ? "E" : "W") +  ", " + abs(round(-py/10)) + (py < 0 ? "S" : "N"), 500, 550)
    text(floor(hr) + ":" + (round(60*(hr%1)) < 10 ? "0" : "") + (round(60*(hr%1))), 500, 570)
    
}
function inventory() {
    
}
function crafting() {
    
}
function pause() {
    let sav = ran + " " + round(px) + " " + round(py)
    if(ps) {
        if(!con2) {
        fill(0, 0, 100)
        rect(150, 100, 300, 400)
        textSize(30)
        fill(255, 255, 255)
        text("Paused", 245, 170)
        textSize(20)
        fill(mouseX > 180 && mouseX < 400 && mouseY > 210 && mouseY < 255 ? color(200, 200, 200) : color(255, 255, 255))
        text("QUIT", 190, 240)
        fill(mouseX > 180 && mouseX < 400 && mouseY > 255 && mouseY < 320 ? color(200, 200, 200) : color(255, 255, 255))
        text("GET SAVE CODE", 190, 290)
        fill(mouseX > 180 && mouseX < 400 && mouseY > 320 && mouseY < 355 ? color(200, 200, 200) : color(255, 255, 255))
        text("CONTROLS", 190, 340)
        mousePressed = function() {if(ps) {
            if(mouseX > 180 && mouseX < 400) {
            if(mouseY > 190 && mouseY < 235 && ps) {Program.restart()} 
            else if(mouseY > 235 && mouseY < 290 && ps) {
                println(sav)
                
            } else if(mouseY > 290 && mouseY < 335 && ps) {
                con2 = true
            }
        }}}
        }
        if(con2) {
            fill(0, 0, 100)
            rect(150, 100, 300, 400)
            textSize(30)
            fill(255, 255, 255)
            text("CONTROLS", 230, 150)
            textSize(18)
            text(tcontrol, 180, 250)
            fill(0, 0, 200)
            rect(170, 440, 90, 40)
            fill(255, 255, 255)
            text("BACK", 190, 465)
            if(mouseIsPressed && mouseX > 170 && mouseX < 260 && mouseY > 440 && mouseY < 480) {
                con2 = false
            }
        }
    }
}
//} displayed functions
//{
function water() {
}
function time() {
    hr += 0.0005
    if(hr > 19 || hr < 5) {f = 0.05}
    if(hr > 5 && hr < 8) {
        f += 0.00024
        f = constrain(f, 0, 1)
    }
    if(hr > 8 && hr < 17) {
        f = 1
    }
    if(hr > 17 && hr < 20) {
        f -= 0.00024
        f = constrain(f, 0, 1)
    }
    println(f)
}
//} other game mechanic functions
//{
function island(x, y) {
    let n = seed.nextGaussian(), ch = 0, unique = [], c = [new PVector(x, y)]
    
    let dir = (n < -1 && new PVector(0, -20)) || (n > -1 && n < 0 && new PVector(20, 0)) || (n > 0 && n < 1 && new PVector(0, 20)) || (n > 1 && new PVector(-20, 0))
    for(let i = 0; i < islandSize; i++) {
        
        n = seed.nextGaussian()
        dir = (n < -1 && new PVector(0, -20)) || (n > -1 && n < 0 && new PVector(20, 0)) || (n > 0 && n < 1 && new PVector(0, 20)) || (n > 1 && new PVector(-20, 0))
        
        let rand = c.length*seed.nextGaussian()
        c.push(new PVector(c[ch].x+dir.x, c[ch].y+dir.y))
        
        ch = abs(round(c.length*seed.nextGaussian()))
        ch = constrain(ch, 0, c.length-1)
    }
    for(let i = 0; i < c.length; i++) {
        for(let j = 0; j < c.length; j++) {
            if(c[i] && c[j] && c[i].x === c[j].x && c[i].y === c[j].y && i !== j) {
                c.splice(j, 1) 
            }
        }
    }
    for(let i = 0; i < c.length; i++) {
        bs.push(new Land(c[i].x, c[i].y))
    }
}
function controls() {
    let x = keys[RIGHT] ? spd : keys[LEFT] ? -spd : 0
    let y = keys[UP] ? -spd : keys[DOWN] ? spd : 0
    for(let i = 0; i < bs.length; i++) {
        bs[i].x -= x
        bs[i].y -= y
    }
    for(let i = 0; i < plants.length; i++) {
        plants[i].x -= x
        plants[i].y -= y
    }
    px -= x
    py -= y
}
function player() {
    if(keys[RIGHT] && !keys[DOWN] && !keys[UP] && 90) {pd = 90}
    else if (keys[RIGHT] && keys[UP] && !keys[DOWN] && 50) {pd = 45} 
    else if (keys[UP] && !keys[RIGHT] && !keys[LEFT]) {pd = 0}
    else if (keys[UP] && keys[LEFT] && !keys[RIGHT]) {pd = -45}
    else if (keys[LEFT] && !keys[UP] && !keys[RIGHT] && !keys[DOWN]) {pd = -90}
    else if (keys[LEFT] && keys[DOWN] && !keys[UP]) {pd = -135}
    else if (keys[RIGHT] && keys[DOWN] && !keys[UP]) {pd = 135}
    else if (keys[DOWN] && !keys[UP] && !keys[RIGHT] && !keys[LEFT]) {pd = 180}
    pushMatrix()
    translate(300, 300)
    scale(0.5)
    rotate(pd)
    noStroke()
    fill(f*150, f*150, f*150)
    rect(12, 10, 10, -35)
    rect(-20, 10, 10, -35)
    stroke(f*150, f*100, 0)
    strokeWeight(5)
    fill(f*150, f*150, 0)
    rect(-15, -15, 30, 30)
    popMatrix()
}
function init() {
        for(let i = 0; i < islands.length; i++) {
        if(islands[i].c.length < islandSize && !islands[i].finish) {
            for(let j = 0; j < loadSpeed; j++) {islands[i].lb()}
        } else if(!islands[i].finish) {
            dup = true
        }
        if(dup) {islands[i].rd()}
    }    
    if(islands.every(function(e) {return e.finish})) {
        loading = false
        for(let i = 0; i < bs.length; i++) {
            bs[i].check()
        }
        check++
    }
    if(loading) {
        let ajk = round(100*(islands[0].c.length/islandSize))
        background(c1)
        textSize(30)
        ajk = constrain(ajk, 0, 100)
        text("Loading " + ajk, 230, 300)
    }
}
function game() {
    c1 = color(0, 0, f*150)
    pushMatrix()    
    scale(2)
    background(c1)
    for(let i = 0; i < bs.length; i++) {bs[i].draw()}
    popMatrix()
    player()
    pushMatrix()    
    scale(2)
    for(let i = 0; i < plants.length; i++) {plants[i].draw()}
    popMatrix()
    if(!loading && !ps) {controls()}
    water()
    HUD()
    pause()
    time()
    inventory()
    crafting()
    init()
}
//} main game mechanic functions 
//{
function back() {
    fill(0, 0, 200)
    rect(30, 540, 90, 40)
    fill(255, 255, 255)
    text("BACK", 50, 565)
    
    if(mouseIsPressed) {
        if(mouseX > 30 && mouseX < 120 && mouseY > 540 && mouseY < 580) {sc = "home"}
    }
}
function option(y, op, v, n) {
    for(let i = 0; i < op.length; i++) {
        fill(v === n[i] ? color(50, 50, 255) : color(0, 0, 220))
        rect(260+i*108, y, 90, 40)
        fill(255, 255, 255)
        text(op[i], 272+i*109, y+25)
    }
}
function options() {
    background(c1)
    textSize(30)
    text("OPTIONS", 250, 100)
    textSize(18)
    text("ISLAND SIZE\n\nLOAD SPEED\n\nMOVEMENT SPEED\n(LAND)", 50, 200)
    option(170, ["MEDIUM", "LARGE", "HUGE"], islandSize, [300, 600, 1000])
    option(230, ["SLOW", "MEDIUM", "FAST"], loadSpeed, [10, 20, 30])
    option(290, ["SLOW", "MEDIUM", "FAST"], spd, [0.4, 0.7, 1])
    if(mouseIsPressed) {
        if(mouseY > 170 && mouseY < 210) {
            if(mouseX > 260 && mouseX < 350) {islandSize = 300}
            else if(mouseX > 368 && mouseX < 458) {islandSize =  600}
            else if(mouseX > 476 && mouseX < 566) {islandSize = 1000} 
        }
        if(mouseY > 230 && mouseY < 270) {
            if(mouseX > 260 && mouseX < 350) {loadSpeed = 10}
            else if(mouseX > 368 && mouseX < 458) {loadSpeed = 20}
            else if(mouseX > 476 && mouseX < 566) {loadSpeed = 30}
        }
        if(mouseY > 290 && mouseY < 330) {
            if(mouseX > 260 && mouseX < 350) {spd = 0.4}
            else if(mouseX > 368 && mouseX < 458) {spd = 0.7}
            else if(mouseX > 476 && mouseX < 566) {spd = 1}
        }
    }
    back()
}
function control() {
    background(c1)
    fill(255, 255, 255)
    textSize(30)
    text("CONTROLS", 220, 130)
    textSize(20)
    text(tcontrol, 80, 200)
    back()
}
function home() {
    background(c1)
    let cond = [
        mouseX > 400 && mouseY > 180 && mouseY < 240,
        mouseX > 400 && mouseY > 240 && mouseY < 280, 
        mouseX > 400 && mouseY > 280 && mouseY < 320, 
        mouseX > 400 && mouseY > 320 && mouseY < 380, 
    ]
    let t = ["NEW GAME", "LOAD GAME", "CONTROLS", "OPTIONS"]
    
    if(loading) {
    }
    for(let i = 0; i < hm.length; i++) {
        for(let j = 0; j < hm[i].length; j++) {
            switch(hm[i][j]) {
                case "1": 
                    fill(240, 240, 175)
                    rect(j*15+220, i*15+200, 15, 15); 
                break;
                case "2":
                    fill(0, 150, 0)
                    rect(j*15+220, i*15+200, 15, 15)
                break;
                case "3":
                    fill(10, 117, 166);
                    rect(j*15+220, i*15+200, 15, 15)
            }
        }
    }
    
    textFont(createFont("sans-serif"))
    fill(255, 255, 255)
    textSize(30)
    text("STRANDED", 50, 270)
    textSize(60)
    text("KHAN", 50, 320)
    
    textFont(createFont("monospace"))
    textSize(20)
    for(let i = 0; i < t.length; i++) {
        fill(cond[i] ? color(200, 200, 200) : color(255, 255, 255))
        text(t[i], 440, 230+i*40)
    }
    
    if(mouseIsPressed) {
        if(cond[0]) {sc = "game"; loading = true}
        if(cond[1]) {sc = "load"}
        if(cond[2]) {sc = "controls"}
        if(cond[3]) {sc = "options"}
    }
}
//} home screen functions
draw = function() {
    keyPressed = function() {
        keys[keyCode] = true
        if(key.toString() === "z") {ps = !ps}
    }
    keyReleased = function() {keys[keyCode] = false}
    switch(sc) {
        case "home": home(); break
        case "game": game(); break
        case "options": options(); break
        case "controls": control(); break
    }
    textSize(15)
    fill(255, 255, 255)
    text(round(this.__frameRate), 10, 20)
}
