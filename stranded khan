/*
see full version history at 

https://github.com/patrick4007019/khanacademy/commits/main/stranded%20khan

*/
//jshint asi: true
//jshint esnext: true

//{
noStroke()
let ran = round(random(0, 10000))
let sc = "home", keys = [], seed = new Random(ran), bs = [], px = 0, py = 0, pd = 0, loading, islands = [], dup = false, finish = false, check = 0, ps = false, con2 = false, hr = 8, trees = [], on = 0, ox = 100, he = 100, others = [], dl = false, pushing = false, removed = false, check = 0, menu = 0, invm = [], che = 0, doing3 = false
let res = [0]
let tcontrol = "Arrow Keys to move\nA to open crafting menu\nF to open inventory\nZ to toggle pause menu\nE to interact with an item"
let hm = [
    "00000000330000000",
    "00000333133000000",
    "00033311113300000",
    "00331111213330000",
    "03331112211130000",
    "00311222221130000",
    "0333112222113000",
    "00331122211330",
    "000331122211330",
    "00331112211133000",
    "00033311111133000",
    "00000333113300000",
    "00000003333000000"
]
let c1 = color(0, 0, 150)
let f = 1
//} basic vars
//{
//put your save code here:
let savecode = ""
//island size
let islandSize = 400
//load speed
let loadSpeed = 2
//player speed 
let spd = 0.7
//
//} setting vars
//{
function Palm(x, y) {
    this.x = x
    this.y = y
    this.draw = function() {
        stroke(0, f*150, 0)
        strokeWeight(2)
        fill(0, f*255, f*98)
        rect(this.x+2, this.y+2, 16, 16, 3)
        fill(0, f*255, f*150);
        rect(this.x+5, this.y+5, 10, 10, 2)
    }
}
function Rock(x, y) {
    this.x = x
    this.y = y
    this.draw = function() {
        fill(f*100, f*100, f*100)
        stroke(f*50, f*50, f*50)
        strokeWeight(1)
        rect(this.x+8, this.y+8, 4, 4)
    }
}
//} plant/resource constructors
//{
function Land(x, y) {
    this.x = x
    this.y = y
    this.checked = 0
    this.rand = seed.nextGaussian()
    this.check = function() {
        if(check === 0) {
        this.count = 0
        for(let i = 0; i < bs.length; i++) {
            if(
            (bs[i].x === this.x-20 && bs[i].y === this.y) ||
            (bs[i].x === this.x+20 && bs[i].y === this.y) ||
            (bs[i].x === this.x && bs[i].y === this.y-20) || 
            (bs[i].x === this.x && bs[i].y === this.y+20) ||
            (bs[i].x === this.x-20 && bs[i].y === this.y-20) ||
            (bs[i].x === this.x-20 && bs[i].y === this.y+20) ||
            (bs[i].x === this.x+20 && bs[i].y === this.y-20) ||
            (bs[i].x === this.x+20 && bs[i].y === this.y+20)
            ) {
                this.count++
            }
        }
        if(this.count > 9) {
            if(this.rand < -0.85) {
                trees.push(new Palm(this.x, this.y))
            }
        }
        if(this.rand > -0.85 && this.rand < -0.5) {
            others.push(new Rock(this.x, this.y))
        }
        }
    }
    this.check()
    this.draw = function() {
        this.col = color(0, f*(230-(this.count-8)*7), 0);
        if(this.count <= 9) {this.col = color(f*255, f*255, f*150)}
        stroke(this.col)
        strokeWeight(1)
        fill(this.col)
        rect(this.x, this.y, 20, 20)
    }
}
function Island(x, y) {
    {
    this.x = x
    this.y = y
    this.n = seed.nextGaussian()
    this.ch = 0
    this.unique = []
    this.ri = 0
    this.sb = 0
    this.c = [new PVector(x, y)]
    this.dir = (this.n < -1 && new PVector(0, -20)) || (this.n > -1 && this.n < 0 && new PVector(20, 0)) || (this.n > 0 && this.n < 1 && new PVector(0, 20)) || (this.n > 1 && new PVector(-20, 0))
    this.finish = false
    this.final = false
    }
    this.lb = function() {
        this.n = seed.nextGaussian()
        this.dir = (this.n < -1 && new PVector(0, -20)) || (this.n > -1 && this.n < 0 && new PVector(20, 0)) || (this.n > 0 && this.n < 1 && new PVector(0, 20)) || (this.n > 1 && new PVector(-20, 0))
        if(this.c[this.ch]) {this.c.push(new PVector(this.c[this.ch].x+this.dir.x, this.c[this.ch].y+this.dir.y))}
        this.ch = abs(round(this.c.length*seed.nextGaussian()))
        this.ch = constrain(this.ch, 0, this.c.length-1)
    }
    this.rd = function() {if(this.removing) {
        for(let i = 0; i < 1; i++) {
        for(let j = 0; j < this.c.length; j++) {
            if(this.c[this.ri] && this.c[j] && this.c[this.ri].x === this.c[j].x && this.c[this.ri].y === this.c[j].y && this.ri !== j) {
                this.c.splice(j, 1) 
            }
        }
            this.ri++
        }
        if(this.ri >= this.c.length-2) {
            this.pushing = true
            for(let i = 0; i < this.c.length; i++) {
                //bs.push(new Land(this.c[i].x, this.c[i].y))
            }

            dup = false
            this.finish = true
            this.removing = false
        }
        
    }}
    this.push = function() {
        bs.push(new Land(this.c[this.sb].x, this.c[this.sb].y))
        this.sb++
        
        if(this.sb >= this.c.length-1) {
            this.pushing = false
            this.final = true
        }
    }
}
for(let i = 1; i < 4; i++) {for(let j = 1; j < 4; j++) {
    islands.push(new Island(i*700-1300, j*700-1300))
}}
//} land constructors
//{
function df(e) {
    return round(dist(e.x, e.y, 140, 140))
}
function pickup() {
    let rocks = others.filter(function(e) {
        return e.constructor === Rock
    })
    rocks.sort(function(a,b) {
        return round(dist(a.x, a.y, 140, 140))-round(dist(b.x, b.y, 140, 140))
    })
    if(rocks.some(function(e) {return df(e) < 15})) {
        fill(255, 255, 255)
        text("E to pick up", 50, 560)
        if(keyIsPressed && key.toString() === "e") {
            others.splice(others.indexOf(rocks[0]), 1)
            res[0]++
        }
    }
}
function capac(name, resource, weight) {
    if(resource > 0) {
        if(!invm.includes(name)) {
            invm.push(name)
        }
        fill(255, 255, 255)
        text(name + "         " + resource + "         " + weight, 170+invm.indexOf(name)*30, 220)
    } else {invm.splice(invm.indexOf(name), 1)}
}
function inventory() {
    fill(100, 100, 155)
    rect(120, 100, 360, 400)
    fill(255, 255, 255)
    textSize(20)
    text("Name           weight", 170, 170)
    textSize(15)
    capac("Rocks", res[0]/2, 1)
}
//} inventory
//{
function crafting() {
    
}
//}
//{
function HUD() {
    fill(255, 255, 255)
    textSize(15)
    text("Press Z to pause game", 210, 15)
    text(abs(round(-px/10*2)) + (px < 0 ? "E" : "W") +  ", " + abs(round(-py/10)) + (py < 0 ? "S" : "N"), 500, 550)
    text(floor(hr) + ":" + (round(60*(hr%1)) < 10 ? "0" : "") + (round(60*(hr%1))), 500, 570)
    stroke(50, 50, 50);
    strokeWeight(2)
    if(ox < 100) {
        fill(200, 200, 200)
        rect(150, 40, 300, 5)
        fill(0, 255, 255)
        rect(150, 40, ox*3, 5)
    }
    fill(200, 200, 200)
    rect(150, 25, 300, 5)
    fill(255, 0, 0)
    rect(150, 25, he*3, 5)
}
function mc(me) {
    if(me === menu) {menu = 0}
    else {menu = me}
}
function crafting() {
    
}
function pause() {
    let sav = ran + " " + islandSize + " " + round(px) + " " + round(py)
    if(ps) {
        if(!con2) {
        fill(0, 0, 100)
        rect(150, 100, 300, 400)
        textSize(30)
        fill(255, 255, 255)
        text("Paused", 245, 170)
        textSize(20)
        fill(mouseX > 180 && mouseX < 400 && mouseY > 210 && mouseY < 255 ? color(200, 200, 200) : color(255, 255, 255))
        text("QUIT", 190, 240)
        fill(mouseX > 180 && mouseX < 400 && mouseY > 255 && mouseY < 320 ? color(200, 200, 200) : color(255, 255, 255))
        text("GET SAVE CODE", 190, 290)
        fill(mouseX > 180 && mouseX < 400 && mouseY > 320 && mouseY < 355 ? color(200, 200, 200) : color(255, 255, 255))
        text("CONTROLS", 190, 340)
        mousePressed = function() {if(ps) {
            if(mouseX > 180 && mouseX < 400) {
            if(mouseY > 190 && mouseY < 235 && ps) {Program.restart()} 
            else if(mouseY > 235 && mouseY < 290 && ps) {
                println(sav)
                
            } else if(mouseY > 290 && mouseY < 355 && ps) {
                con2 = true
            }
        }}}
        }
        if(con2) {
            fill(0, 0, 100)
            rect(150, 100, 300, 400)
            textSize(30)
            fill(255, 255, 255)
            text("CONTROLS", 230, 150)
            textSize(15)
            text(tcontrol, 180, 250)
            fill(0, 0, 200)
            rect(170, 440, 90, 40)
            fill(255, 255, 255)
            text("BACK", 190, 465)
            if(mouseIsPressed && mouseX > 170 && mouseX < 260 && mouseY > 440 && mouseY < 480) {
                con2 = false
            }
        }
    }
}
//} displayed functions
//{
function health() {
    he += ox <= 0 ? -0.05 : 0.01
    he = constrain(he, 0, 100)
}
function water() {
    on = bs.filter(function(e) {
        return e.x >= 130 && e.x <= 150 && e.y >= 130 && e.y <= 150
    }).length >= 1
    if(!on) {
        ox -= 0.03
    } else {
        ox += 0.08
    }
    ox = constrain(ox, 0, 100)
}
function time() {
    hr += 0.0005
    if(hr > 19 || hr < 5) {f = 0.05}
    if(hr > 5 && hr < 8) {
        f += 0.00024
        f = constrain(f, 0, 1)
    }
    if(hr > 8 && hr < 17) {
        f = 1
    }
    if(hr > 17 && hr < 20) {
        f -= 0.00024
        f = constrain(f, 0, 1)
    }
}
//} other game mechanic functions
//{
function controls() {
    let x = keys[RIGHT] ? (on ? spd : spd/3) : keys[LEFT] ? -(on ? spd : spd/3) : 0
    let y = keys[UP] ? -(on ? spd : spd/3) : keys[DOWN] ? (on ? spd : spd/3) : 0
    for(let i = 0; i < bs.length; i++) {
        bs[i].x -= x
        bs[i].y -= y
    }
    for(let i = 0; i < trees.length; i++) {
        trees[i].x -= x
        trees[i].y -= y
    }
    for(let i = 0; i < others.length; i++) {
        others[i].x -= x
        others[i].y -= y
    }
    px -= x
    py -= y
}
function player() {
    if(keys[RIGHT] && !keys[DOWN] && !keys[UP] && 90) {pd = 90}
    else if (keys[RIGHT] && keys[UP] && !keys[DOWN] && 50) {pd = 45} 
    else if (keys[UP] && !keys[RIGHT] && !keys[LEFT]) {pd = 0}
    else if (keys[UP] && keys[LEFT] && !keys[RIGHT]) {pd = -45}
    else if (keys[LEFT] && !keys[UP] && !keys[RIGHT] && !keys[DOWN]) {pd = -90}
    else if (keys[LEFT] && keys[DOWN] && !keys[UP]) {pd = -135}
    else if (keys[RIGHT] && keys[DOWN] && !keys[UP]) {pd = 135}
    else if (keys[DOWN] && !keys[UP] && !keys[RIGHT] && !keys[LEFT]) {pd = 180}
    pushMatrix()
    translate(300, 300)
    scale(0.5)
    rotate(pd)
    noStroke()
    fill(f*150, f*150, f*150)
    rect(12, 10, 10, -35)
    rect(-20, 10, 10, -35)
    stroke(f*150, f*100, 0)
    strokeWeight(5)
    fill(f*150, f*150, 0)
    rect(-15, -15, 30, 30)
    popMatrix()
}
function init() {
    for(let i = 0; i < islands.length; i++) {
        if(islands[i].c.length < islandSize && !islands[i].finish) {
            for(let j = 0; j < loadSpeed; j++) {islands[i].lb()}
        } else if(!islands[i].finish) {
            dup = true
        }
        if(dup) {islands[i].removing = true}
    }    
    if(islands.some(function(e) {return e.finish})) {
        removed = true
    } 
    if(islands.every(function(e) {return e.final})) {
        doing3 = true
    } 
    for(let i = 0; i < islands.length; i++) {
        if(islands[i].pushing) {
            islands[i].push()
        }
    }
    if(loading) {
        let total = islands.reduce(function(a, b) {
            return a+b.ri
        }, 0)
        let total2 = bs.length/islands.reduce(function(a,b) {
            return a+b.c.length
        }, 0)
        let ajk2 = round(100*(islands[0].c.length/islandSize))
        background(c1)
        textSize(30)
        ajk2 = constrain(ajk2, 0, 100)
        fill(255, 255, 255)
        if(ajk2 > 95) {dl = true}
        if(!dl) {text("Loading Map " + ajk2, 180, 290)}
        else if(!removed) {text("Removing Duplicates", 140, 290)}
        else if(!doing3) {text("Creating Map " + round(total2*100), 160, 290)}
        else {text("Coloring Map " + round(che/bs.length*100), 160, 290)}
        ox = 100
    }
    if(doing3 && loading) {
        for(let i = 0; i < 10; i++) {
            bs[che+i].check()
        }
        che += 10
        if(che >= bs.length-15) {
            check++
            loading = false
        }
    }
}
function game() {
    c1 = color(0, 0, f*150)
    pushMatrix()    
    scale(2)
    background(c1)
    for(let i = 0; i < islands.length; i++) {
        if(islands[i].removing) {
        islands[i].rd()
        }
    }
    for(let i = 0; i < bs.length; i++) {bs[i].draw()}
    for(let i = 0; i < others.length; i++) {others[i].draw()}
    popMatrix()
    player()
    pushMatrix()    
    scale(2)
    for(let i = 0; i < trees.length; i++) {trees[i].draw()}
    popMatrix()
    if(!loading && !ps) {controls()}
    water()
    HUD()
    water()
    pause()
    time()
    switch(menu) {
        case 1: inventory(); break
        case 2: crafting();
    }
    health()
    pickup()
    init()
}
//} main game mechanic functions 
//{
function back() {
    fill(0, 0, 200)
    rect(30, 540, 90, 40)
    fill(255, 255, 255)
    text("BACK", 50, 565)
    
    if(mouseIsPressed) {
        if(mouseX > 30 && mouseX < 120 && mouseY > 540 && mouseY < 580) {sc = "home"}
    }
}
function option(y, op, v, n) {
    for(let i = 0; i < op.length; i++) {
        fill(v === n[i] ? color(50, 50, 255) : color(0, 0, 220))
        rect(260+i*108, y, 90, 40)
        fill(255, 255, 255)
        text(op[i], 272+i*109, y+25)
    }
}
function options() {
    background(c1)
    textSize(30)
    text("OPTIONS", 250, 100)
    textSize(15)
    textSize(18)
    text("ISLAND SIZE\n\nMOVEMENT SPEED\n(LAND)", 50, 200)
    option(170, ["MEDIUM", "LARGE", "HUGE"], islandSize, [200, 400, 800])
    option(230, ["SLOW", "MEDIUM", "FAST"], spd, [0.4, 0.7, 1])
    if(mouseIsPressed && sc === "options") {
        if(mouseY > 170 && mouseY < 210) {
            if(mouseX > 260 && mouseX < 350) {islandSize = 200}
            else if(mouseX > 368 && mouseX < 458) {islandSize =  400}
            else if(mouseX > 476 && mouseX < 566) {islandSize = 800} 
        }
        if(mouseY > 230 && mouseY < 270) {
            if(mouseX > 260 && mouseX < 350) {spd = 0.4}
            else if(mouseX > 368 && mouseX < 458) {spd = 0.7}
            else if(mouseX > 476 && mouseX < 566) {spd = 1}
        }
    }
    back()
}
function control() {
    background(c1)
    fill(255, 255, 255)
    textSize(30)
    text("CONTROLS", 220, 130)
    textSize(20)
    text(tcontrol, 80, 200)
    back()
}
function home() {
    background(c1)
    let cond = [
        mouseX > 400 && mouseY > 180 && mouseY < 240,
        mouseX > 400 && mouseY > 240 && mouseY < 280, 
        mouseX > 400 && mouseY > 280 && mouseY < 320, 
        mouseX > 400 && mouseY > 320 && mouseY < 380, 
    ]
    let t = ["NEW GAME", "LOAD GAME", "CONTROLS", "OPTIONS"]
    
    if(loading) {
    }
    for(let i = 0; i < hm.length; i++) {
        for(let j = 0; j < hm[i].length; j++) {
            switch(hm[i][j]) {
                case "1": 
                    fill(240, 240, 175)
                    rect(j*15+220, i*15+200, 15, 15); 
                break;
                case "2":
                    fill(0, 150, 0)
                    rect(j*15+220, i*15+200, 15, 15)
                break;
                case "3":
                    fill(10, 117, 166);
                    rect(j*15+220, i*15+200, 15, 15)
            }
        }
    }
    
    textFont(createFont("sans-serif"))
    fill(255, 255, 255)
    textSize(30)
    text("STRANDED", 50, 270)
    textSize(60)
    text("KHAN", 50, 320)
    
    textFont(createFont("monospace"))
    textSize(20)
    for(let i = 0; i < t.length; i++) {
        fill(cond[i] ? color(200, 200, 200) : color(255, 255, 255))
        text(t[i], 440, 230+i*40)
    }
    
    if(mouseIsPressed) {
        if(cond[0]) {sc = "game"; loading = true}
        if(cond[1]) {sc = "load"}
        if(cond[2]) {sc = "controls"}
        if(cond[3]) {sc = "options"}
    }
}
//} home screen functions
draw = function() {
    keyPressed = function() {
        keys[keyCode] = true
        switch(key.toString()) {
            case "z": ps = !ps; break
            case "f": mc(1); break
            case "a": mc(2)
        }
    }
    keyReleased = function() {keys[keyCode] = false}
    switch(sc) {
        case "home": home(); break
        case "game": game(); break
        case "options": options(); break
        case "controls": control(); break
    }
    textSize(15)
    fill(255, 255, 255)
    text(round(this.__frameRate), 10, 20)
}
